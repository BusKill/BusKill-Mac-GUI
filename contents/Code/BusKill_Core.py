import os
import fnmatch
import sys
import subprocess
import BusKill_GUIElements
from PyQt5.QtCore import QThread

class Controller:

    def __init__(self):
        print(os.getcwd())

    def _getTriggers(self):
        try:
            self.Triggers = []
            self.dirlist = os.listdir("../Triggers/")
            for dir in self.dirlist:
                print(dir)
                if os.path.isdir(os.path.join("../Triggers/", dir)) == True:
                    self.Triggers.append(dir)
            return self.Triggers
        except FileNotFoundError:
            self._errorHandling("Critical", "No Triggers Found")
            return ["0"]

    def _getDevices(self):
        self.Devices = os.listdir("/dev")
        self.Disk_Devices = ["DUMMY DATA"]
        for Device in self.Devices:
            if fnmatch.fnmatch(Device, "*disk*"):
                if Device.startswith("r") == False:
                    if fnmatch.fnmatch(Device, "*isk*s*") == False:
                        if Device.endswith("1") == False:
                            if Device.endswith("0") == False:
                                self.Disk_Devices.append(Device)
        return self.Disk_Devices

    def _getConfig(self):
        try:
            self.Config = []
            self.dirlist = os.listdir("../Config/")
            self.Config.append("DUMMY DATA")
            #shit tonne of if statements

            return self.Config
        except FileNotFoundError:
            self._writeLog("INFO", "Check for config... None Found")
            pass

    def _executeTrigger(self, Trigger):
        subprocess.call("python ../../Triggers/",Trigger,"Trigger.py", shell = True)

    def _checkDevice(self, Device):
        if os.path.exists("/dev/"+Device) == True:
            return True
        else:
            return False
            #add WriteLog in here

    def _validation(self, Trigger ,Device):
        Trig = True
        Dev = True
        #add some actual validation in here.
        #add some specific self._errorHandling() Messages Depending on what has failed Validation
        return Trig and Dev

    #unsupported
    def _createConfig(self):
        function = None
    #unsupported
    def _exportLog(self):
        function = None
    #unsupported
    def _selectLogSaveLocation(self):
        function = None
    #unsupported
    def _selectTriggerInstaller(self):
        function = None
    #unsupported
    def _writeLog(self, Severity, Message):
        function = None

    def _errorHandling(self, Severity, Message):
        if Severity.lower() == "critical":
            window = BusKill_GUIElements.BusKill_CritMessage(Message)
        #elif Severity.lower() == "informative":
            #window = BusKill_GUIElements.BusKill_InfoMessage(Message)

        self._writeLog(Severity, Message)

class Runtime(QThread):

    def __init__(self, Trigger, Device):
        QThread.__init__(self)
        self.APP_CTRL = Controller()
        self.Trigger = Trigger
        self.Device = Device
        self.runs = True

    def __del__(self):
        self.wait()

    def run(self):
        Triggered = False
        while Triggered == False and self.runs == True:
            if self.APP_CTRL._checkDevice(self.Device) == False:
                self.APP_CTRL._executeTrigger(self.Trigger)
                Triggered = True
        return

    def stop(self):
        self.runs = False

class Configuration:

    def __init__(self):
        pass

    def _createConfig(self, name, Device, Trigger):
        if os.path.exists(os.path.join("Config/",name,".BSConf")) == False:
            with open("Config/"+name+".BSConf","a") as NewConfig:
                NewConfig.write("THIS FILE CAN BE MODIFIED MANUALLY. IF IT FAILS VALIDATION PLEASE CLEAR CONFIGURATION \n")
                NewConfig.write("Trigger:"+Trigger+"\n")
                NewConfig.write("Device:"+Device+"\n")
                NewConfig.write("this file was generated by buskill")
        else:
            function = None
            #return an error pop up, go back to main

    def _getConf(self, name):
        self.values = []
        try:
            with open("Config/"+name+".BSConf") as Conf:
                self.values.append(Conf.readlines()[1].split(":")[1]) #Trigger
                self.values.append(Conf.readline()[2].split(":")[1]) #Device
                return self.values
        except IOError:
            function = None
            #return an error pop up and go back to main
